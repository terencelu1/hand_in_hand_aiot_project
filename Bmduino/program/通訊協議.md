# BMduino 與樹莓派通訊協議

## 概述

BMduino 透過 Native USB (SerialUSB) 與樹莓派進行通訊，使用 USB CDC (Virtual COM Port) 協議。

- **波特率**：115200
- **數據格式**：8N1 (8 數據位，無校驗，1 停止位)
- **通訊方式**：文本格式，以換行符 `\n` 結束

---

## 1. 樹莓派接收訊息（BMduino → 樹莓派）

### 1.1 待機模式輸出

**格式**：
```
STANDBY,物體溫度,環境溫度,心率,血氧
```

**範例**：
```
STANDBY,25.50,23.20,72,98
STANDBY,25.51,23.21,0,0
```

**說明**：
- 每 1 秒輸出一次
- 物體溫度：GY-906 測量的物體溫度（攝氏度）
- 環境溫度：GY-906 測量的環境溫度（攝氏度）
- 心率：MAX30102 測量的心率（BPM），無數據時為 0
- 血氧：MAX30102 測量的血氧（%），無數據時為 0

### 1.2 工作模式輸出

#### 進入工作模式
```
WORKING,START
```

#### 狀態更新（每 1 秒）
**格式**：
```
WORKING,物體溫度,環境溫度,心率,血氧
```

**範例**：
```
WORKING,25.50,23.20,MEASURING,MEASURING
WORKING,25.51,23.21,MEASURING,87
WORKING,25.52,23.22,72,87
```

**說明**：
- 物體溫度：GY-906 測量的物體溫度（攝氏度）
- 環境溫度：GY-906 測量的環境溫度（攝氏度）
- 心率：如果已測到則顯示數值（30-140 BPM），否則顯示 `MEASURING`
- 血氧：如果已測到則顯示數值（%），否則顯示 `MEASURING`

#### 完成測量
**格式**：
```
WORKING,FINAL,指紋ID,物體溫度,環境溫度,心率,血氧
```

**範例**：
```
WORKING,FINAL,1,25.50,23.20,72,98
WORKING,FINAL,5,26.30,25.45,85,95
```

**說明**：
- 當心率和血氧都測到且穩定 3 秒後輸出
- 指紋ID：觸發工作模式的指紋編號（1-127）
- 物體溫度：GY-906 測量的物體溫度（攝氏度）
- 環境溫度：GY-906 測量的環境溫度（攝氏度）
- 心率：MAX30102 測量的心率（30-140 BPM）
- 血氧：MAX30102 測量的血氧（%）
- 完成後自動回到待機模式

#### 錯誤訊息

**沒有手指**：
```
WORKING,NO_FINGER
```

**沒有數據**（45 秒內沒有有效數據）：
```
WORKING,NO_DATA
```

**超時**（45 秒超時）：
```
WORKING,TIMEOUT
```

### 1.3 接收模式輸出

#### 進入接收模式
```
MODE,RECEIVE
```

#### 繼電器控制成功
**格式**：
```
RELAY_OK,繼電器編號
```

**範例**：
```
RELAY_OK,1
RELAY_OK,2
```

#### 錯誤訊息

**無效的繼電器編號**：
```
RELAY_ERROR,INVALID_NUMBER
```

**無效的命令**：
```
RELAY_ERROR,INVALID_COMMAND
```

#### 回到待機模式
```
MODE,STANDBY
```

---

## 2. 樹莓派傳送訊息（樹莓派 → BMduino）

### 2.1 繼電器控制命令

**格式**：
```
RELAY,繼電器編號
```

**範例**：
```
RELAY,1
RELAY,2
RELAY,3
RELAY,4
```

**說明**：
- 繼電器編號：1-4
- 命令必須以換行符 `\n` 結束
- 執行完畢後自動回到待機模式

**回應**：
- 成功：`RELAY_OK,繼電器編號`
- 失敗：`RELAY_ERROR,INVALID_NUMBER` 或 `RELAY_ERROR,INVALID_COMMAND`

---

## 3. Python 範例程式

### 3.1 接收訊息範例

```python
import serial
import time

# 連接串口
ser = serial.Serial('/dev/ttyACM0', 115200, timeout=1)  # 根據實際 COM 埠調整

try:
    while True:
        if ser.in_waiting > 0:
            line = ser.readline().decode('utf-8').strip()
            
            if line.startswith('STANDBY,'):
                # 解析待機模式數據
                parts = line.split(',')
                object_temp = float(parts[1])
                ambient_temp = float(parts[2])
                heart_rate = int(parts[3]) if parts[3] != '0' else None
                spo2 = int(parts[4]) if parts[4] != '0' else None
                
                print(f"待機模式 - 物體溫度: {object_temp}°C, 環境溫度: {ambient_temp}°C")
                if heart_rate:
                    print(f"  心率: {heart_rate} BPM, 血氧: {spo2}%")
            
            elif line.startswith('WORKING,START'):
                print("進入工作模式")
            
            elif line.startswith('WORKING,FINAL,'):
                # 解析工作模式最終數據
                parts = line.split(',')
                fingerprint_id = int(parts[2])
                object_temp = float(parts[3])
                ambient_temp = float(parts[4])
                heart_rate = int(parts[5])
                spo2 = int(parts[6])
                
                print(f"測量完成 - 指紋ID: {fingerprint_id}")
                print(f"  物體溫度: {object_temp}°C, 環境溫度: {ambient_temp}°C")
                print(f"  心率: {heart_rate} BPM, 血氧: {spo2}%")
            
            elif line.startswith('WORKING,'):
                # 解析工作模式狀態更新
                parts = line.split(',')
                if len(parts) == 5:
                    object_temp = float(parts[1])
                    ambient_temp = float(parts[2])
                    heart_rate = parts[3]
                    spo2 = parts[4]
                    
                    print(f"工作模式 - 物體溫度: {object_temp}°C, 環境溫度: {ambient_temp}°C")
                    print(f"  心率: {heart_rate}, 血氧: {spo2}")
            
            elif line.startswith('RELAY_OK,'):
                relay_num = int(line.split(',')[1])
                print(f"繼電器 {relay_num} 控制成功")
            
            elif line.startswith('RELAY_ERROR,'):
                error = line.split(',')[1]
                print(f"繼電器控制錯誤: {error}")
            
            else:
                print(f"收到: {line}")
        
        time.sleep(0.01)

except KeyboardInterrupt:
    print("\n停止監聽")
finally:
    ser.close()
```

### 3.2 傳送命令範例

```python
import serial
import time

# 連接串口
ser = serial.Serial('/dev/ttyACM0', 115200, timeout=1)

def control_relay(relay_num):
    """控制繼電器"""
    if relay_num < 1 or relay_num > 4:
        print("錯誤：繼電器編號必須在 1-4 之間")
        return False
    
    command = f"RELAY,{relay_num}\n"
    ser.write(command.encode('utf-8'))
    print(f"發送命令: {command.strip()}")
    
    # 等待回應
    time.sleep(0.5)
    if ser.in_waiting > 0:
        response = ser.readline().decode('utf-8').strip()
        print(f"回應: {response}")
        return response.startswith('RELAY_OK')
    
    return False

# 使用範例
if __name__ == "__main__":
    try:
        # 控制繼電器 1
        control_relay(1)
        time.sleep(2)
        
        # 控制繼電器 2
        control_relay(2)
        
    except Exception as e:
        print(f"錯誤: {e}")
    finally:
        ser.close()
```

### 3.3 完整通訊類別範例

```python
import serial
import threading
import time
from typing import Optional, Callable

class BMduinoCommunicator:
    """BMduino 通訊類別"""
    
    def __init__(self, port: str, baudrate: int = 115200):
        self.ser = serial.Serial(port, baudrate, timeout=1)
        self.running = False
        self.callbacks = {
            'standby': [],
            'working_start': [],
            'working_status': [],
            'working_final': [],
            'relay_ok': [],
            'error': []
        }
    
    def register_callback(self, event: str, callback: Callable):
        """註冊回調函數"""
        if event in self.callbacks:
            self.callbacks[event].append(callback)
    
    def start_listening(self):
        """開始監聽"""
        self.running = True
        thread = threading.Thread(target=self._listen_loop, daemon=True)
        thread.start()
    
    def stop_listening(self):
        """停止監聽"""
        self.running = False
    
    def _listen_loop(self):
        """監聽迴圈"""
        while self.running:
            if self.ser.in_waiting > 0:
                line = self.ser.readline().decode('utf-8', errors='ignore').strip()
                self._process_message(line)
            time.sleep(0.01)
    
    def _process_message(self, line: str):
        """處理訊息"""
        if line.startswith('STANDBY,'):
            parts = line.split(',')
            data = {
                'object_temp': float(parts[1]),
                'ambient_temp': float(parts[2]),
                'heart_rate': int(parts[3]) if parts[3] != '0' else None,
                'spo2': int(parts[4]) if parts[4] != '0' else None
            }
            for callback in self.callbacks['standby']:
                callback(data)
        
        elif line == 'WORKING,START':
            for callback in self.callbacks['working_start']:
                callback()
        
        elif line.startswith('WORKING,FINAL,'):
            parts = line.split(',')
            data = {
                'fingerprint_id': int(parts[2]),
                'object_temp': float(parts[3]),
                'ambient_temp': float(parts[4]),
                'heart_rate': int(parts[5]),
                'spo2': int(parts[6])
            }
            for callback in self.callbacks['working_final']:
                callback(data)
        
        elif line.startswith('WORKING,'):
            parts = line.split(',')
            if len(parts) == 5:
                data = {
                    'object_temp': float(parts[1]),
                    'ambient_temp': float(parts[2]),
                    'heart_rate': parts[3],
                    'spo2': parts[4]
                }
                for callback in self.callbacks['working_status']:
                    callback(data)
        
        elif line.startswith('RELAY_OK,'):
            relay_num = int(line.split(',')[1])
            for callback in self.callbacks['relay_ok']:
                callback(relay_num)
    
    def control_relay(self, relay_num: int) -> bool:
        """控制繼電器"""
        if relay_num < 1 or relay_num > 4:
            return False
        
        command = f"RELAY,{relay_num}\n"
        self.ser.write(command.encode('utf-8'))
        return True
    
    def close(self):
        """關閉連接"""
        self.stop_listening()
        if self.ser.is_open:
            self.ser.close()

# 使用範例
if __name__ == "__main__":
    comm = BMduinoCommunicator('/dev/ttyACM0')
    
    # 註冊回調
    def on_standby(data):
        print(f"待機模式: {data}")
    
    def on_working_final(data):
        print(f"測量完成 - 指紋ID: {data['fingerprint_id']}")
        print(f"  心率={data['heart_rate']} BPM, 血氧={data['spo2']}%")
    
    comm.register_callback('standby', on_standby)
    comm.register_callback('working_final', on_working_final)
    
    # 開始監聽
    comm.start_listening()
    
    try:
        # 控制繼電器
        comm.control_relay(1)
        time.sleep(10)
    except KeyboardInterrupt:
        pass
    finally:
        comm.close()
```

---

## 4. 數據格式說明

### 4.1 溫度格式
- **單位**：攝氏度（°C）
- **精度**：小數點後 2 位
- **範圍**：通常 -40°C 到 125°C

### 4.2 心率格式
- **單位**：BPM (Beats Per Minute)
- **範圍**：30-140 BPM
- **無效值**：0 或 `MEASURING`

### 4.3 血氧格式
- **單位**：百分比（%）
- **範圍**：通常 70-100%
- **無效值**：0 或 `MEASURING`

---

## 5. 錯誤處理

### 5.1 常見錯誤

**串口連接失敗**：
- 檢查 USB 連接
- 確認 COM 埠號碼
- 檢查驅動程式

**沒有回應**：
- 確認 BMduino 程式已上傳
- 檢查波特率設定（115200）
- 確認 Native USB 連接

**數據解析錯誤**：
- 檢查數據格式是否正確
- 確認換行符處理
- 處理編碼錯誤（使用 `errors='ignore'`）

### 5.2 建議的錯誤處理

```python
try:
    line = ser.readline().decode('utf-8', errors='ignore').strip()
    if line:
        # 處理數據
        pass
except UnicodeDecodeError:
    # 處理編碼錯誤
    pass
except ValueError:
    # 處理數據解析錯誤
    pass
except serial.SerialException as e:
    # 處理串口錯誤
    print(f"串口錯誤: {e}")
```

---

## 6. 通訊流程圖

### 6.1 待機模式流程
```
BMduino → 樹莓派: STANDBY,數據 (每1秒)
```

### 6.2 工作模式流程
```
BMduino → 樹莓派: WORKING,START
BMduino → 樹莓派: WORKING,狀態 (每1秒)
BMduino → 樹莓派: WORKING,FINAL,數據 (完成)
```

### 6.3 接收模式流程
```
樹莓派 → BMduino: RELAY,1
BMduino → 樹莓派: MODE,RECEIVE
BMduino → 樹莓派: RELAY_OK,1
BMduino → 樹莓派: MODE,STANDBY
```

---

## 7. 注意事項

1. **命令格式**：所有命令必須以換行符 `\n` 結束
2. **數據解析**：使用逗號分隔解析數據
3. **錯誤處理**：建議使用 try-except 處理所有通訊錯誤
4. **超時處理**：工作模式最多 45 秒，超時會輸出 `WORKING,TIMEOUT`
5. **數據驗證**：心率必須在 30-140 BPM 範圍內才有效
6. **狀態追蹤**：建議追蹤當前模式狀態，以便正確處理訊息

---

## 8. 快速參考

### 8.1 接收訊息格式

| 訊息類型 | 格式 | 說明 |
|---------|------|------|
| 待機模式 | `STANDBY,溫度,溫度,心率,血氧` | 每1秒 |
| 工作開始 | `WORKING,START` | 指紋辨識成功 |
| 工作狀態 | `WORKING,溫度,溫度,心率,血氧` | 每1秒，MEASURING表示測量中 |
| 工作完成 | `WORKING,FINAL,指紋ID,溫度,溫度,心率,血氧` | 測量完成 |
| 繼電器成功 | `RELAY_OK,編號` | 繼電器控制成功 |
| 模式切換 | `MODE,RECEIVE` 或 `MODE,STANDBY` | 模式切換通知 |

### 8.2 傳送命令格式

| 命令 | 格式 | 說明 |
|------|------|------|
| 控制繼電器 | `RELAY,1` 到 `RELAY,4` | 控制指定繼電器 |

---

## 9. 樹莓派串口設定

### 9.1 查找串口設備

```bash
# 查看所有串口設備
ls /dev/ttyACM* /dev/ttyUSB*

# 查看串口詳細信息
dmesg | grep tty
```

### 9.2 權限設定

```bash
# 將用戶加入 dialout 群組
sudo usermod -a -G dialout $USER

# 重新登入後生效
```

### 9.3 安裝 Python 依賴

```bash
pip install pyserial
```

---

## 10. 測試範例

### 10.1 簡單測試腳本

```python
#!/usr/bin/env python3
import serial
import time

ser = serial.Serial('/dev/ttyACM0', 115200, timeout=1)

print("開始監聽 BMduino...")
try:
    while True:
        if ser.in_waiting > 0:
            line = ser.readline().decode('utf-8', errors='ignore').strip()
            print(f"[{time.strftime('%H:%M:%S')}] {line}")
        time.sleep(0.01)
except KeyboardInterrupt:
    print("\n停止")
finally:
    ser.close()
```

### 10.2 發送命令測試

```python
#!/usr/bin/env python3
import serial
import time
import sys

if len(sys.argv) < 2:
    print("用法: python send_command.py RELAY,1")
    sys.exit(1)

ser = serial.Serial('/dev/ttyACM0', 115200, timeout=1)
command = sys.argv[1] + '\n'
ser.write(command.encode('utf-8'))
print(f"發送: {command.strip()}")

time.sleep(1)
if ser.in_waiting > 0:
    response = ser.readline().decode('utf-8').strip()
    print(f"回應: {response}")

ser.close()
```

